---
title: Typegen
---

<!-- Needs technical review -->

# Typegen

<!-- deps: ["context-typescript","events-typescript","promise-services"] -->

**Warning: This feature is in beta!** Read the section below on known limitations to find out what we’re actively looking to improve.

You can automatically generate intelligent typings for XState using our [VS Code extension](https://marketplace.visualstudio.com/items?itemName=statelyai.stately-vscode) or our [CLI](/packages/xstate-cli).

How to get started:

1. Download and install the [VS Code extension](https://marketplace.visualstudio.com/items?itemName=statelyai.stately-vscode) **or** install the [CLI](/packages/xstate-cli) and run the `xstate typegen` command with the `--watch` flag.
2. Open a new file and create a new machine, passing the schema attributes:

```ts
import { createMachine } from 'xstate';

const machine = createMachine({
  schema: {
    context: {} as { value: string },
    events: {} as { type: 'FOO'; value: string } | { type: 'BAR' },
  },
  initial: 'a',
  states: {
    a: {
      on: {
        FOO: {
          actions: 'consoleLogValue',
          target: 'b',
        },
      },
    },
    b: {
      entry: 'consoleLogValueAgain',
    },
  },
});
```

3. Add `tsTypes: {}` to the machine and save the file:

```ts
const machine = createMachine({
  tsTypes: {},
  schema: {
    context: {} as { value: string },
    events: {} as { type: 'FOO'; value: string } | { type: 'BAR' },
  },
  initial: 'a',
  states: {
    a: {},
    b: {},
  },
});
```

4. The extension should automatically add a generic to the machine:

```ts
const machine = createMachine({
  tsTypes: {} as import('./filename.typegen').Typegen0,
  /* ... */
});
```

5. Add a second parameter into the `createMachine` call. This second parameter is where you implement the machine’s actions, services, guards and delays.

```ts
const machine = createMachine(
  {
    /* ... */
  },
  {
    actions: {
      consoleLogValue: (context, event) => {
        // Wow! event is typed to { type: 'FOO' }
        console.log(event.value);
      },
      consoleLogValueAgain: (context, event) => {
        // Wow! event is typed to { type: 'FOO' }
        console.log(event.value);
      },
    },
  }
);
```

Now the events in the options are _strongly typed to the events that cause the action to be triggered_, including actions, guards, services and delays.

You’ll also notice that `state.matches`, `tags` and other parts of the machine are now type-safe.

## Typing promise services

You can use the generated types to specify the return type of promise-based services by using the `services` schema property:

```ts
import { createMachine } from 'xstate';

createMachine(
  {
    schema: {
      services: {} as {
        myService: {
          // The data that gets returned from the service
          data: { id: string };
        };
      },
    },
    invoke: {
      src: 'myService',
      onDone: {
        actions: 'consoleLogId',
      },
    },
  },
  {
    services: {
      myService: async () => {
        // This return type is now type-safe
        return {
          id: '1',
        };
      },
    },
    actions: {
      consoleLogId: (context, event) => {
        // This event type is now type-safe
        console.log(event.data.id);
      },
    },
  }
);
```

## Typegen best practices

Below are some recommendations to help you get the most out of using typegen.

### Use named actions, guards, and services

We recommend using named actions, guards, and services instead of inline actions, guards and services.

Named actions, services and guards allow for:

- Better visualization with the names appearing in the statechart
- Easier-to-understand code
- Overrides in `useMachine` or `machine.withConfig`

The following example is optimal:

```ts
createMachine(
  {
    entry: ['sayHello'],
  },
  {
    actions: {
      sayHello: () => {
        console.log('Hello!');
      },
    },
  }
);
```

The following example is useful but less optimal:

```ts
createMachine({
  entry: [
    () => {
      console.log('Hello!');
    },
  ],
});
```

### The generated files

We recommend you gitignore the generated files (`*filename*.typegen.ts`) from your repository.

You can use the [CLI](/packages/xstate-cli) to regenerate them on CI, for instance, via a postinstall script:

```json
{
  "scripts": {
    "postinstall": "xstate typegen \"./src/**/*.ts?(x)\""
  }
}
```

### Don’t use enums

Enums were a common pattern used with XState TypeScript and were often used to declare state names as follows:

```ts
enum States {
  A,
  B,
}

createMachine({
  initial: States.A,
  states: {
    [States.A]: {},
    [States.B]: {},
  },
});
```

You can then check `state.matches(States.A)` on the resulting machine, which allows for type-safe checks of state names.

With typegen, using enums is no longer necessary as all `state.matches` types are type-safe. Enums are currently not supported by our static analysis tool. We’re unlikely to support enums with typegen due to the complexity they add for comparatively little gain.

Instead of enums, use typegen and rely on the strength of the type-safety provided.

## Known limitations

There are a few known limitations with typegen, which we are working to fix.

### Always transitions and raised events

Typegen might incorrectly annotate actions, services, guards and delays if they are called “in response” to always transitions or raised events. We are working on fixing this, both in XState and in the typegen.

## Config Objects

The generic types for `MachineConfig<TContext, any, TEvent>` are the same as those for `createMachine<TContext, TEvent>`, which is useful when you are defining a machine config object _outside_ of the `createMachine(...)` function, and helps prevent [inference errors](https://github.com/statelyai/xstate/issues/310):

```ts
import { MachineConfig } from 'xstate';

const myMachineConfig: MachineConfig<TContext, any, TEvent> = {
  id: 'controller',
  initial: 'stopped',
  states: {
    stopped: {
      /* ... */
    },
    started: {
      /* ... */
    },
  },
  // ...
};
```
