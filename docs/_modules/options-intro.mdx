---
deps: ["what-is-a-statechart", "transitions-and-events"]
title: "Introduction to Options"
group: basics
loom: 01e1dabbb3e64b7997d62e165ce9b7e5
status: complete # in-progress, complete
needs: # content, tech-review, copy-review
---

{/* TODO: Maybe re-record this loom \ */}

Statecharts require that a machine is separated into two parts. The first part is the machine’s **config**. The config describes _how the machine behaves_ — its states, events and transitions.

The second part is a machine’s **options** — implementation details that expand the machine’s capabilities.

Options can:

- Make decisions based on checks, such as an `if/else` statement
- Make changes to the machine’s surrounding environment
- Subscribe to changes from the machine’s outside environment

In XState, the separation is divided between:

| Term    | Description             |
| ------- | ----------------------- |
| Config  | What the machine does   |
| Options | How the machine does it |

Below is an example where we describe in our config that when the machine first starts, it 'says hello', using the `sayHello` action.

```ts twoslash
import { createMachine } from "xstate";

const helloMachine = createMachine({
  /**
   * Below is an 'action' — we’ll
   * learn more about actions later
   */
  entry: ["sayHello"],
});
```

{/* Add visualisation to the above \ */}

As a visualization, the config is readable. But the machine doesn’t _do_ anything yet.

**Options** let us pass an implementation for the `sayHello` action.

```ts twoslash
import { createMachine } from "xstate";

const helloMachine = createMachine(
  {
    entry: ["sayHello"],
  },
  {
    actions: {
      sayHello: () => {
        console.log("Hello!");
      },
    },
  },
);
```

The separation between “what your code does” and “how your code does it” is powerful because it allows you to understand its purpose without requiring you to read through the implementation details.
