---
deps: ["use-interpret", "intro-to-state-api"]
status: complete # in-progress, complete
needs: # content, tech-review, copy-review
group: running-machines
---

You can use `useSelector` to subscribe to a machine created with `useInterpret` or `interpret`. `useSelector` gives you fine-grained control over when your components should re-render and is particularly valuable for good performance.

```tsx twoslash
import { createMachine, StateFrom } from "xstate";
import { useInterpret, useSelector } from "@xstate/react";

const machine = createMachine({
  initial: "hovered",
  states: {
    hovered: {},
    notHovered: {},
  },
});

const selector = (state: StateFrom<typeof machine>) =>
  state.matches("hovered");

const Component = () => {
  const actor = useInterpret(machine);

  const isHovered = useSelector(actor, selector);

  return null;
};
```

In the example above, the component will only re-render when the `isHovered` value changes from `true` to `false`.

Internally, `useSelector` compares the previous value (`prev`) and the next value (`next`) to determine whether a re-render is required. Strict equality is used for its default check: `prev === next`. If the check returns true, there will be no re-render.

You can customize the check by passing a `compare` function to `useSelector`:

```tsx twoslash
import { createMachine, StateFrom } from "xstate";
import { useInterpret, useSelector } from "@xstate/react";

const machine = createMachine({
  context: {
    numbers: [1, 2, 3],
  },
});

const getNumbers = (state: StateFrom<typeof machine>) =>
  state.context.numbers;

const Component = () => {
  const actor = useInterpret(machine);

  const numbers = useSelector(
    actor,
    getNumbers,
    (prev, next) => {
      /**
       * Checks if 1,2,3 === 2,3,4
       */
      return prev.join() === next.join();
    },
  );

  return null;
};
```

The compare function is needed in the example above because comparing two arrays by `[] === []` would _always_ result in a re-render.
