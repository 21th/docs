---
deps: ["assign-action", "machine-services"]
group: invoking-services
status: complete # in-progress, complete
needs: # content, tech-review, copy-review
---

Sometimes invoking services may not be flexible enough for your needs. In such cases, you might want to:

- Invoke child machines that last across several states when machines invoked with `invoke` are tied to that state
- Invoke a dynamic number of services

You can use a powerful tool called `spawn` to run these services in these cases. Services created with spawn are **spawning actors**, and services created with invoke are **invoking services**.

Spawning actors puts a reference to the machine in `context`, which means that you must always assign a spawned actor to context via `assign`:

```ts twoslash
import { createMachine, spawn, assign } from "xstate";

const childMachine = createMachine({
  /* ... */
});

const parentMachine = createMachine({
  entry: [
    assign({
      childMachineRef: () => spawn(childMachine),
    }),
  ],
});
```

In the example above, the spawned actor can now be referenced on the `context` of the machine. You can spawn as many actors as you need:

```ts twoslash {5-7}
import { createMachine, spawn, assign } from "xstate";

const childMachine = createMachine({
  /* ... */
});

// ---cut---
const parentMachine = createMachine({
  entry: [
    assign({
      childMachineRefs: () => [
        spawn(childMachine),
        spawn(childMachine),
        spawn(childMachine),
      ],
    }),
  ],
});
```
