---
title: 'Context'
---

In XState, `context` is how you store data in a state machine actor.

It is a special property that is available in all states and is used to store data that is relevant to the state machine. The `context` object is immutable, so you cannot directly modify it. Instead, you use the `assign(...)` action to update `context`.

```ts
import { createMachine } from 'xstate';

const feedbackMachine = createMachine({
  // Initialize the state machine with context
  context: {
    feedback: 'Some feedback',
  },
});

const feedbackActor = interpret(feedbackMachine);

feedbackActor.subscribe((state) => {
  console.log(state.context.feedback);
});

feedbackActor.start();
// logs 'Some feedback'
```

<!-- TODO: add link below -->

The `context` property is _optional_; if the state machine only specifies [finite states](#), then it may not need `context`.

## Stately Editor: context

- Setting initial values
- Updating context with assign
- JS/TS export

## Initial context

The initial context of a machine is set in the `context` property of the machine config.

```ts
import { createMachine } from 'xstate';

const feedbackMachine = createMachine({
  context: {
    feedback: 'Some feedback',
    rating: 5,
    // other properties
  },
});
```

The object that you pass to `context` will be the initial `context` value for any actor that is created from this machine.

:::warningxstate

It is important that you do not mutate the `context` object. Instead, you should use the `assign(...)` action to update `context` immutably. If you mutate the `context` object, you may get unexpected behavior, such as mutating the `context` of other actors.

:::

### Lazy initial context

Context can be initialized lazily by passing a function that returns the initial `context` value:

```ts
const feedbackMachine = createMachine({
  context: () => ({
    feedback: 'Some feedback',
    createdAt: Date.now(),
  }),
});

const feedbackActor = interpret(feedbackMachine).start();

console.log(feedbackActor.getSnapshot().context.createdAt);
// logs the current timestamp
```

Lazy initial context is evaluated per actor, so each actor will have its own `context` object.

### Input

You can provide input data to a machine's initial `context` by passing an `input` property to the `interpret(machine, { input })` function and using the `input` property from the first argument in the `context` function:

```ts
const feedbackMachine = createMachine({
  context: ({ input }) => ({
    feedback: '',
    rating: input.defaultRating,
  }),
});

const feedbackActor = interpret(feedbackMachine, {
  input: {
    defaultRating: 5,
  },
}).start();

console.log(feedbackActor.getSnapshot().context.rating);
// logs 5
```

<!-- TODO: add link below -->

Learn more about [input](#).

## Updating context with `assign(...)`

Context is updated by using the `assign(...)` action in a transition:

```ts
import { createMachine, assign } from 'xstate';

const feedbackMachine = createMachine({
  context: {
    feedback: 'Some feedback',
  },
  on: {
    'feedback.update': {
      actions: assign({
        feedback: ({ event }) => event.feedback,
      }),
    },
  },
});

const feedbackActor = interpret(feedbackMachine);

feedbackActor.subscribe((state) => {
  console.log(state.context.feedback);
});

feedbackActor.start();

// logs 'Some feedback'

feedbackActor.send({
  type: 'feedback.update',
  feedback: 'Some other feedback',
});

// logs 'Some other feedback'
```

## TypeScript

```ts
const machine = createMachine({
  schema: {} as {
    context: {
      feedback: string;
      rating: number;
    };
  },
  entry: ({ context }) => {
    context.feedback; // string
    context.rating; // number
  },
});
```

## Cheatsheet

## Resources
