---
title: 'State machines'
---

A state machine is a model that describes the behavior of something (e.g. an [actor](#todo)). Finite state machines describe how the state of an actor transitions to another state when an event occurs.

- Benefits of state machines
  State machines help build reliable software by making it easier to prevent impossible states and undesired transitions.

- How are state machines useful?

## Creating a state machine

In XState, a state machine (referred to as a "machine") is created using the `createMachine(config)` function:

```ts
import { createMachine } from 'xstate';

const feedbackMachine = createMachine({
  id: 'feedback',
  initial: 'question',
  states: {
    question: {
      on: {
        'feedback.good': {
          target: 'thanks',
        },
      },
    },
    thanks: {
      // ...
    },
    // ...
  },
});
```

In this example, the machine has two states: `question` and `thanks`. The `question` state has a transition to the `thanks` state when the `feedback.good` event is sent to the machine:

```ts
const feedbackActor = interpret(feedbackMachine);

feedbackActor.subscribe((state) => {
  console.log(state.value);
});

feedbackActor.start();
// logs 'question'

feedbackActor.send({ type: 'feedback.good' });
// logs 'thanks'
```

## Interpreting machines

A machine can be considered a "blueprint" for an actor. An [actor](#todo) is a running instance of the machine; in other words, it is the entity whose logic is described by the machine.

To create an actor, interpret the machine using the `interpret(machine)` function:

```ts
import { interpret } from 'xstate';

const feedbackActor = interpret(feedbackMachine);

feedbackActor.subscribe((state) => {
  console.log(state.value);
});

feedbackActor.start();
// logs 'question'
```

## Providing implementations

Machine implementations refer to the language-specific code that is executed that is not directly related to the state machine's logic. This includes:

- [Actions](#todo)
- [Actors](#todo)
- [Guards](#todo)
- [Delays](#todo)

Typically, you will reference implementations using strings or objects, such as `{ type: 'doSomething' }`, and then create a new machine with default implementations in the 2nd argument:

```ts
import { createMachine } from 'xstate';

const feedbackMachine = createMachine(
  // Machine config
  {
    // ...
  },
  // Default implementations
  {
    actions: {
      doSomething: () => {
        console.log('Doing something!');
      },
    },
    actors: {
      /* ... */
    },
    guards: {
      /* ... */
    },
    delays: {
      /* ... */
    },
  }
);
```

Those references are then resolved to the actual provided implementation:

```ts
const feedbackMachine = createMachine({
  entry: { type: 'doSomething' },
  // ...
});

const feedbackActor = interpret(feedbackMachine).start();

// logs 'Doing something!'
```

You can override default implementations by _providing_ implementations via `machine.provide(...)`. This function will create a new machine with the same config, but with the provided implementations:

```ts
const customFeedbackMachine = feedbackMachine.provide({
  actions: {
    doSomething: () => {
      console.log('Doing something custom!');
    },
  },
});

const feedbackActor = interpret(customFeedbackMachine).start();

// logs 'Doing something custom!'
```

## Specifying types

TypeScript types can be specified inside the machine config, in the `.types` property:

```ts
const feedbackMachine = createMachine({
  types: {} as {
    context: { feedback: string };
    events: { type: 'feedback.good' } | { type: 'feedback.bad' };
    actions: { type: 'logTelemetry' };
  },
});
```

These types will be inferred throughout the machine config, as well as in the created machine and actor, so that methods such as `machine.transition(...)` and `actor.send(...)` will be type-safe.

## Typegen

_Coming soon_

## Transition method

A machine's `machine.transition(state, event)` method is a pure method that returns the next state given the current state and an event:

```ts
const feedbackMachine = createMachine({
  initial: 'question',
  states: {
    question: {
      on: {
        'feedback.good': {
          target: 'thanks',
        },
      },
    },
    thanks: {
      // ...
    },
    // ...
  },
});

const { initialState } = feedbackMachine;

const nextState = feedbackMachine.transition(initialState, {
  type: 'feedback.good',
});
```

The `machine.transition(...)` method is useful for testing or building a custom interpreter.

- [Testing](#todo)
- [Custom interpreters](#todo)

## API

Link to API

## TypeScript

## Cheatsheet

**Create a machine**

```ts
import { createMachine } from 'xstate';

const machine = createMachine({
  initial: 'start',
  states: {
    start: {},
    // ...
  },
});
```

**Provide implementations**

```ts
import { createMachine } from 'xstate';

const machine = createMachine({
  // ...
});

const machineWithImpls = machine.provide({
  actions: {
    /* ... */
  },
  actors: {
    /* ... */
  },
  guards: {
    /* ... */
  },
  delays: {
    /* ... */
  },
});
```

## Resources
