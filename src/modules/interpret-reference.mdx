---
deps: ['running-machines-intro']
group: 'reference'
status: in-progress # in-progress, complete
needs: content # content, tech-review, copy-review
---

# Interpreting Machines

While a state machine/statechart with a pure `.transition()` function is useful for flexibility, purity, and testability, in order for it to have any use in a real-life application, something needs to:

- Keep track of the current state, and persist it
- Execute side-effects
- Handle delayed transitions and events
- Communicate with external actors

The **interpreter** is responsible for _interpreting_ the state machine/statechart and doing all of the above - that is, parsing and executing it in a runtime environment. An interpreted, running instance of a statechart is called a **actor**.

## Interpreter

An optional interpreter is provided that you can use to run your statecharts. The interpreter handles:

- State transitions
- Executing actions (side-effects)
- Delayed events with cancellation
- Activities (ongoing actions)
- Invoking/spawning child statechart actors
- Support for multiple listeners for state transitions, context changes, events, etc.
- And more!

```js
import { createMachine, interpret } from 'xstate';

const machine = createMachine(/* machine config */);

// Interpret the machine, and add a listener for whenever a transition occurs.
const actor = interpret(machine).onTransition((state) => {
  console.log(state.value);
});

// Start the actor
actor.start();

// Send events
actor.send({ type: 'SOME_EVENT' });

// Stop the actor when you are no longer using it.
actor.stop();
```

## Sending Events

Events are sent to a running actor by calling `actor.send(event)`. There are 3 ways an event can be sent:

```js {5,8,12}
actor.start();

// As an object (preferred):
actor.send({ type: 'CLICK', x: 40, y: 21 });

// As a string:
// (same as actor.send({ type: 'CLICK' }))
actor.send('CLICK');

// As a string with an object payload:
// (same as actor.send({ type: 'CLICK', x: 40, y: 21 }))
actor.send('CLICK', { x: 40, y: 21 });
```

- As an event object (e.g., `.send({ type: 'CLICK', x: 40, y: 21 })`)
  - The event object must have a `type: ...` string property.
- As a string (e.g., `.send('CLICK')`, which resolves to sending `{ type: 'CLICK' }`)
  - The string represents the event type.
- As a string followed by an object payload (e.g., `.send('CLICK', { x: 40, y: 21 })`)
  - The first string argument represents the event type.
  - The second argument must be an object without a `type: ...` property.

::: warning
If the actor is not initialized (that is, if `actor.start()` wasn't called yet), events will be **deferred** until the actor is started. This means that the events won't be processed until `actor.start()` is called, and then they will all be sequentially processed.

This behavior can be changed by setting `{ deferEvents: false }` in the [actor options](#options). When `deferEvents` is `false`, sending an event to an uninitialized actor will throw an error.
:::

## Batched Events

Multiple events can be sent as a group, or "batch", to a running actor by calling `actor.send(events)` with an array of events:

```js
actor.send([
  // String events
  'CLICK',
  'CLICK',
  'ANOTHER_EVENT',
  // Event objects
  { type: 'CLICK', x: 40, y: 21 },
  { type: 'KEYDOWN', key: 'Escape' },
]);
```

This will immediately schedule all batched events to be processed sequentially. Since each event causes a state transition that might have actions to execute, actions in intermediate states are deferred until all events are processed, and then they are executed with the state they were created in (not the end state).

This means that the end state (after all events are processed) will have an `.actions` array of _all_ of the accumulated actions from the intermediate states. Each of these actions will be bound to their respective intermediate states.

::: warning

Only one state -- the **end state** (i.e., the resulting state after all events are processed) -- will be sent to the `.onTransition(...)` listener(s). This makes batched events an optimized approach for performance.

:::

::: tip

Batched events are useful for [event sourcing](https://martinfowler.com/eaaDev/EventSourcing.html) approaches. A log of events can be stored and later replayed by sending the batched events to an actor to arrive at the same state.

:::

## Starting and Stopping

The actor can be initialized (i.e., started) and stopped with `.start()` and `.stop()`. Calling `.start()` will immediately transition the actor to its initial state. Calling `.stop()` will remove all listeners from the actor, and do any listener cleanup, if applicable.

```js
const actor = interpret(machine);

// Start the machine
actor.start();

// Stop the machine
actor.stop();

// Restart the machine
actor.start();
```

Actors can be started from a specific [state](./states.md) by passing the `state` into `actor.start(state)`. This is useful when rehydrating the actor from a previously saved state.

```js
// Starts the actor from the specified state,
// instead of from the machine's initial state.
actor.start(previousState);
```

## Executing Actions

[Actions (side-effects)](./actions.md) are, by default, executed immediately when the state transitions. This is configurable by setting the `{ execute: false }` option (see example). Each action object specified on the `state` might have an `.exec` property, which is called with the state's `context` and `event` object.

Actions can be executed manually by calling `actor.execute(state)`. This is useful when you want to control when actions are executed:

```js
const actor = interpret(machine, {
  execute: false, // do not execute actions on state transitions
});

actor.onTransition((state) => {
  // execute actions on next animation frame
  // instead of immediately
  requestAnimationFrame(() => actor.execute(state));
});

actor.start();
```

## Options

The following options can be passed into the interpreter as the 2nd argument (`interpret(machine, options)`):

- `execute` (boolean) - Signifies whether state actions should be executed upon transition. Defaults to `true`.
  - See [Executing Actions](#executing-actions) for customizing this behavior.
- `deferEvents` (boolean) - Signifies whether events sent to an uninitialized actor (i.e., prior to calling `actor.start()`) should be deferred until the actor is initialized. Defaults to `true`.
  - If `false`, events sent to an uninitialized actor will throw an error.
- `devTools` (boolean) - Signifies whether events should be sent to the [Redux DevTools extension](https://github.com/zalmoxisus/redux-devtools-extension). Defaults to `false`.
- `logger` - Specifies the logger to be used for `log(...)` actions. Defaults to the native `console.log` method.
- `clock` - Specifies the [clock interface for delayed actions](./delays.md#interpretation). Defaults to the native `setTimeout` and `clearTimeout` functions.

## Custom Interpreters

You may use any interpreter (or create your own) to run your state machine/statechart. Here's an example minimal implementation that demonstrates how flexible interpretation can be (despite the amount of boilerplate):

```js
const machine = createMachine(/* machine config */);

// Keep track of the current state, and start
// with the initial state
let currentState = machine.initialState;

// Keep track of the listeners
const listeners = new Set();

// Have a way of sending/dispatching events
function send(event) {
  // Remember: machine.transition() is a pure function
  currentState = machine.transition(currentState, event);

  // Get the side-effect actions to execute
  const { actions } = currentState;

  actions.forEach((action) => {
    // If the action is executable, execute it
    typeof action.exec === 'function' && action.exec();
  });

  // Notify the listeners
  listeners.forEach((listener) => listener(currentState));
}

function listen(listener) {
  listeners.add(listener);
}

function unlisten(listener) {
  listeners.delete(listener);
}

// Now you can listen and send events to update state
listen((state) => {
  console.log(state.value);
});

send('SOME_EVENT');
```

## Notes

- The `interpret` function is exported directly from `xstate` since 4.3+ (i.e., `import { interpret } from 'xstate'`). For prior versions, it is imported from `'xstate/lib/interpreter'`.
- Most interpreter methods can be chained:

```js
const actor = interpret(machine)
  .onTransition((state) => console.log(state))
  .onDone(() => console.log('done'))
  .start(); // returns started actor
```

- Do not call `actor.send(...)` directly from actions. This impedes testing, visualization, and analysis. Instead, [use `invoke`](./communication.md).

## Action order

When interpreting statecharts, the order of actions should not necessarily matter (that is, they should not be dependent on each other). However, the order of the actions in the `state.actions` array is:

1. `exit` actions - all the exit actions of the exited state node(s), from the atomic state node up
2. transition `actions` - all actions defined on the chosen transition
3. `entry` actions - all the entry actions of the entered state node(s), from the parent state down

{/* ::: warning \ */}
In XState version 4.x, `assign` actions have priority and are executed before any other actions. This behavior will be fixed in version 5, as the `assign` actions will be called in order.
{/* ::: (end tip/warning) \ */}

{/* ::: danger \ */}

All action creators documented here return **action objects**; it is a pure function that only returns an action object and does _not_ imperatively send an event. Do not imperatively call action creators; they will do nothing!

```js
// ðŸš« Do not do this!
entry: () => {
  // ðŸš« This will do nothing; send() is not an imperative function!
  send({ type: 'SOME_EVENT' });
};

console.log(send({ type: 'SOME_EVENT' }));
// => { type: 'xstate.send', event: { type: 'SOME_EVENT' } }

// âœ… Do this instead
entry: send({ type: 'SOME_EVENT' });
```

{/* ::: (end tip/warning) \ */}
