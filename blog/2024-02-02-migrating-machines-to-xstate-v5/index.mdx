---
title: Migrating machines to XState v5
description: A walkthrough of migrating an existing XState v4 machine to XState v5
tags: [stately, studio, breaking changes, state machines, xstate]
authors: [kevin]
date: 2024-02-02
slug: 2024-02-02-migrating-machines-to-xstate-v5
image: /blog/2024-02-02-migrating-machines-to-xstate-v5.png
---

We recently announced the recent release of XState v5! During its beta phase, we created a migration guide, specifically to call out breaking changes and to give developers onging updates regarding api changes. This post is a walkthrough to migrating existing XState machines from v4 to v5 and is intended to be more of a step-by-step companion to the migration guide.

{/* truncate */}

We at Stately have dozens of XState machines in our own Stately Studio code base and have been migrating those to XState v5 as well. As you can imagine, we use XState v5 in our own applications and have been migrating our existing machines to v5 as well. We’ve learned a lot about the migration process and wanted to share that with you.

The following is a list of steps you can take to migrate an existing XState v4 machine to XState v5.

1. [Install XState v5 and dependencies](#1-install-xstate-v5-and-dependencies)
2. [Move types to `setup()` and remove typegen](#1-move-types-to-setup-and-remove-typegen)
3. [Convert action strings to “parameterized actions”](#3-convert-actions-strings-to-parameterized-actions)
4. [Move implementations or stubs to `setup()`](#4-move-implementations-or-stubs-to-setup)
5. [Provide concrete implementations](#5-provide-concrete-implementations)

### 1. Install XState v5 and dependencies

The first step will be to [install XState v5](https://stately.ai/docs/xstate#installation). You can also install library-specific dependencies if you're using XState with [React](https://stately.ai/docs/xstate-react), [Vue](https://stately.ai/docs/xstate-vue), or [Svelte](https://stately.ai/docs/xstate-svelte).

If you have many state machines and would like to incrementally migrate those to v5, you can install both v4 and v5 side-by-side by [following the steps listed here](https://stately.ai/docs/migration#how-can-i-use-both-xstate-v4-and-v5). Once you've completed those steps, you'll end up with both dependencies in your `package.json`. Here's an example with libraries pegged to the latest version at the time of this writing but you can also use `npm:xstate@latest` if you prefer.

```json5
// package.json after completing the steps in the migration guide
{
  dependencies: {
    xstate: '4.38.2',
    xstate5: 'npm:xstate@5.6.0',
    '@xstate/react': '3.2.2',
    '@xstate/react5': 'npm:@xstate/react@4.0.3',
  },
}
```

:::tip

You can also default `xstate` to v5 and use `xstate4` for v4.

:::

### 2. Move types to `setup()` and remove typegen

One of the first migration steps, based on a breaking change, is to move any TypeScript types from `schema` to be under a new `types` property in the object passed to the new `setup()` function.

If you were previously using typegen in v4, you can also delete `tsTypes` as there is no more typegen in v5.

<Tabs>
<TabItem value="v5" label="XState v5">

```ts
import { setup } from 'xstate';

const machine = setup({
  types: {
    context: {} as {
      /* type context props */
    },
    events: {} as {
      /* type events */
    },
    // Type actors here
    input: {} as {
      nameOfActorSource1: {
        output: {
          prop1: string;
          prop2: number;
          /* etc */
        };
      };
      nameOfActorSource2: {
        /* type actor */
      };
      nameOfActorSource3: {
        /* type actor */
      };
    },
  },
  /* implementations */
  actions: {},
  guards: {},
  actors: {},
}).createMachine({
  /* machine config */
});
```

</TabItem>

<TabItem value="v4" label="XState v4">

```ts
// ❌ DEPRECATED
import { createMachine } from 'xstate';

const machine = createMachine({
  ...
  tsTypes: {} as import('./myMachine.typegen').Typegen0,
  schema: {
    context: {} as {
      /* type context props */
    },
    events: {} as {
      /* type events */
    },
    services: {} as {
      /* type services */
    },
  }
});
```

</TabItem>
</Tabs>

:::warning

You can still pass `types` to `createMachine()` if you are using that on its own and if you prefer. However, if you chain `setup().createMachine()` then you must pass `types` to the call to `setup({ types: {} })`.

:::

### 3. Convert actions strings to “parameterized actions”

We must now [convert any action name strings to action objects](https://stately.ai/docs/migration#use-params-to-pass-params-to-actions--guards) which allows us to define an explicit `params` object (or primitive value) that will be received at runtime by our action implementations. There are two ways to do this:

We can define `params` as a [static value](https://stately.ai/docs/actions#action-objects)

```ts
actions: [
  {
    // Action type
    type: 'track',
    // Action params
    params: { response: 'good' },
  },
],
```

We can also use [dynamic action parameters](https://stately.ai/docs/actions#dynamic-action-parameters), a function that receives `context` and/or `event`, allowing you to map those values to the `params` object.

```ts
entry: [
  {
    type: 'logInitialRating',
    params: ({ context }) => ({
      initialRating: context.initialRating,
    }),
  },
];
```

Here is a more complete example of converting action strings to parameterized actions:

<Tabs>
<TabItem value="v5" label="XState v5">

```ts
import { setup } from 'xstate';

const machine = setup({
  types: {
    events: {} as {
      type: 'next';
      prop1: string;
      prop2: number;
      prop3: boolean;
    },
  },
  /* more setup */
}).createMachine({
  on: {
    next: {
      target: 'first',
      actions: [
        {
          type: 'doThis',
          // Later, the action implementation function will be
          // passed this string value as the 2nd arg, params.
          params: ({ event }) => event.prop1,
        },
        {
          type: 'doThat',
          // Later, the action implementation function will be
          // passed this number value as the 2nd arg, params.
          params: ({ event }) => event.prop2,
        },
      ],
    },
  },
  states: {
    first: {
      entry: {
        type: 'whenEntering',
        // Later, the action implementation function will be
        // passed only these 2 values as the 2nd arg, params.
        params: ({ event }) => ({
          prop1: event.prop1,
          prop2: event.prop2,
        }),
      },
      exit: {
        type: 'whenExiting',
        // Later, the action implementation function will be
        // passed only these 2 values as the 2nd arg, params.
        params: ({ event }) => ({
          prop2: event.prop2,
          prop3: event.prop3,
        }),
      },
    },
  },
});
```

</TabItem>

<TabItem value="v4" label="XState v4">

```ts
// ❌ DEPRECATED
import { createMachine } from 'xstate';

const machine = createMachine({
  on: {
    next: {
      actions: ['doThis', 'doThat'],
    },
  },
  states: {
    first: {
      entry: 'whenEntering',
      exit: 'whenExiting',
    },
  },
});
```

</TabItem>
</Tabs>

### 4. Move implementations or stubs to `setup()`

We must provide implementations for actions, guards, and actors in the object passed to `setup()`. If the machine has everything it needs to carry out these implementations on its own then these will be the actual implementations. However, if the machine needs to receive dependencies from the outside world, then these will be stubs that will be overridden later. You may end up with a combination of concrete implementations and stubs.

:::info

Even dependencies that are external to the machine can be made available to the machine.

:::

**Injecting dependencies using the machine’s `input`**

Dependencies can be made available to the internal workings of a machine by passing them via `input` to that machine.

```ts
setup({
  input: {
    externalDependency1: someRef,
    externalDependency2: anotherRef,
  },
});
```

**Injecting dependencies by sending an event**

Dependencies can be made available to the internal workings of a machine by sending them along with an event. These refs can either be used by actions or actors that receive this event or you could store them in context using an `assign` action.

```ts
send({
  type: 'refs.inject',
  externalDependency1,
  externalDependency2,
});
```

However, in some cases it's just not feasible or convenient to inject dependencies. There may be too many dependencies or perhaps you wish to not tightly couple the machine to those dependencies. In that case, we need to provide a “stub” of these implementations in `setup()` that are meant to be overridden later.

```ts
setup({
  actions: {
    doThis: (_, prop1: string) => {
      // Concrete implementation here
      console.log(prop1);
    },
    // Stubbed implementation
    doThat: (_, prop2: number) => {},
    whenEntering: (_, params: { prop1: string; prop2: number }) => {
      // Concrete implementation here
      console.log(prop1, prop2);
    },
    // Stubbed implementation
    whenExiting: (_, params: { prop2: number; prop3: boolean }) => {},
  },
});
```

### 4. Provide concrete implementations

, by passing them to `.provide({ /* implementations here */ })`.
