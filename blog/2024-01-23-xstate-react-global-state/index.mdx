---
title: Global state with XState and React
description: How to use XState to manage global state in React
tags:
  [
    xstate,
    react
  ]
authors: [david]
date: 2024-01-23
slug: 2024-01-23-xstate-react-global-state
image: /blog/2024-01-23-xstate-react-global-state.png
---

XState is a versatile state management & orchestration library that works with any framework, including React with the [`@xstate/react`](./xstate-react.mdx) package. For many apps, managing global state is a requirement, and there are many options for sharing global state in React, like using [React Context](https://react.dev/learn/passing-data-deeply-with-context) or libraries like [Redux](https://redux.js.org/), [MobX](https://mobx.js.org/), and [Zustand](https://github.com/pmndrs/zustand).

The `@xstate/react` package makes it simple to manage component-level state with hooks like `useMachine()` and `useActor()`, but it works equally well for managing global state ðŸŒŽ

## Global state

The simplest way to manage global state is to share an [actor](./actors.mdx) instance between components. Think of an actor as a "store" â€“ you can subscribe to its state updates ("snapshots") and send events to it.

You can consume that actor in any component either by passing it as a prop or referencing it directly from module scope.

```tsx
import { setup, createActor } from 'xstate';
import { useSelector } from '@xstate/react';

const countMachine = createMachine({
  context: { count: 0 },
  on: {
    inc: {
      actions: assign({ count: ({ context }) => context.count + 1 })
    }
  }
});

// highlight-start
export const countActor = createActor(countMachine)
  .start(); // Starts the actor immediately
// highlight-end

export function App() {
  // highlight-next-line
  const count = useSelector(countActor, (state) => state.context.count);

  return (
    <button onClick={() => countActor.send({ type: 'inc' })}>
      Count: {count}
    </button>
  );
}
```

You can read this global actor ("store") and send events to it from any component:

```tsx
// highlight-next-line
import { countActor } from './countActor';

export function Counter() {
  // highlight-next-line
  const count = useSelector(countActor, (state) => state.context.count);

  return (
    <button onClick={() => countActor.send({ type: 'inc' })}>
      Current count: {count}
    </button>
  );
}
```

## Global effects

Actors are not limited to being state stores. They can also be used to manage side effects, like HTTP requests, or to trigger side effects from within the actor. Because of this, you may not want actors to start immediately. You can use the `.start()` method to start the actor at an appropriate time, such as when the app mounts.

:::tip

If an actor is already started, calling `.start()` again will not do anything. This makes it safe to call in `useEffect()`.

:::

```ts
import { effectfulActor } from './effectfulActor';

export function App() {
  useEffect(() => {
    // highlight-next-line
    effectfulActor.start();
  }, []);

  // ...
}
```

## Global state with React Context

If you prefer to use [React Context](https://react.dev/learn/passing-data-deeply-with-context) to share global state, you can adapt the above pattern to use a React Context provider and consumer.

```tsx
import { createContext } from 'react';

const someMachine = createMachine(/* ... */);
const someActor = createActor(someMachine);

// `someActor` is passed to `createContext` mostly for type safety
// highlight-next-line
export const SomeActorContext = createContext(someActor);

export function App() {
  return (
    // highlight-next-line
    <SomeActorContext.Provider value={someActor}>
      <Counter />
    // highlight-next-line
    </SomeActorContext.Provider>
  );
}
```

```tsx
import { useContext } from 'react';
import { useSelector } from '@xstate/react';
// highlight-next-line
import { SomeActorContext } from './SomeActorContext';

export function Counter() {
  // highlight-next-line
  const someActor = useContext(SomeActorContext);
  const count = useSelector(someActor, (state) => state.context.count);

  return (
    <button onClick={() => someActor.send({ type: 'inc' })}>
      Current count: {count}
    </button>
  );
}
```
